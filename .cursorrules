# Cursor Rules Configuration File

This is a WoW rotation tool. The SDK is one level up under the sdk folder.
wow.d.ts is the main SDK file. Core/Spell.js is critical — load it into context almost always.
Core directory has common utilities, Data has references, Enums are self-explanatory.
DRTracker covers PvP diminishing returns. Debug/DebugWindow.js has one-shot dump buttons.

# Extensions Folder — Check It
The Extensions/ folder contains JS files that patch SDK prototypes at runtime
(e.g. CGUnit, CGActivePlayer, CGObject, Guid, Vector3, AuraData, Party, PartyMember, CGItem).
These add helpers like hasAura, isFacing, getEnemies, timeToDeath, etc. that don't exist in
the base SDK. Matching .d.ts files provide the type declarations. Before writing or modifying
a rotation, load the relevant Extension JS files (not just the .d.ts interfaces) into context
so you know what methods are actually available and how they work under the hood.

# Behavior Tree Gotchas
- bt.Selector evaluates children top-to-bottom; first Success stops the whole branch.
  A spell higher in the list WILL starve everything below it of GCDs if it keeps succeeding.
  Always consider: "if this condition is true every tick, does anything below ever run?"
- Decorator conditions (ret =>) are evaluated every tick. Anything gated by a Decorator
  that returns false will skip its ENTIRE subtree — including all children inside it.
- spell.cast() fails silently if the spell can't actually cast (no resources, out of range, etc.)
  even when ret => returns true. Don't assume ret => true means it always fires.
- spell.cast()'s first arg (spell name/ID) is fixed at tree construction time — build() runs
  once. For talent-dependent spell choices, use separate spell.cast() entries with ret =>
  conditions. Do NOT use a ternary in the first arg — it won't re-evaluate on later ticks.
- spell.cast() accepts variadic functions after the spell name. A function returning
  CGUnit/Guid sets the target; returning false/null/undefined fails the sequence (condition).
  Pattern: spell.cast("Name", on => target, ret => condition).
- Off-GCD abilities (interrupts, Spiritwalker's Grace, etc.) go BEFORE the
  !spell.isGlobalCooldown() Decorator. The GCD Decorator skips its entire subtree during GCD,
  which blocks off-GCD spells if they're inside it.

# SDK Pitfalls
- spell.cast() callback option ({ callback: () => {} }) is dead code — never invoked.
  Use spell.getTimeSinceLastCast("SpellName") for tracking recent casts instead.
- getTimeSinceLastCast() does NOT work for channels — SPELL_CAST_SUCCESS only fires on
  full channel completion. Use me.currentCast === SPELL_ID (numeric) to detect active casts.
- me.currentChannel may not report all channeled spells. Always verify in-game.
- spell.isOnCooldown() on untalented spells causes log spam every tick. Guard with
  spell.isSpellKnown() before calling isOnCooldown()/getCooldown() on optional talents.

# Rotation Design Patterns
- Split cooldowns into burstCooldowns() (gated by burst toggle) and rotationalCooldowns().
- Burst toggle uses combat.burstToggle (from defaultCombatTargeting). Gate burstCooldowns()
  with a hasCooldownsReady() method that checks combat.burstToggle && any CD is off cooldown.
  Wrap in bt.Decorator(ret => this.hasCooldownsReady(), this.burstCooldowns()). Never use a
  custom Settings checkbox for burst — always use the global toggle.
- Charge-based abilities at multiple priorities need careful ordering — anti-cap checks
  BELOW core rotational abilities or they eat GCDs.
- AoE plague/dot checks on "any enemy" cause spam; check current target only for single-target
  applicators and trust AoE spread mechanics.
- Healer CDs: the game's aura cache is ~500ms. Multiple CDs in a Selector can stack on
  consecutive ticks. Use getTimeSinceLastCast() with a 2-3s window to prevent overlap.
  Add a low-HP override so CDs can still stack when someone is dying.

# Aura / Spell ID Rules
- hasAura(), getAura(), getAuraByMe() etc. accept both numeric IDs and string names.
  Prefer numeric IDs defined in a const auras = {} block at the top of the rotation file.
  Use string names only as fallback for unknown/new expansion aura IDs.
- Spell casts always use string names: spell.cast("Spell Name", ...).
- Pet buffs must be checked on Pet.current, not on me.
- New expansion aura IDs are unknown until verified. Use string name as fallback
  (e.g. me.hasAura("Tempest")) — do NOT use 0 as placeholder, it can match unexpectedly.
- isPlayer() checks type === 6 || 7. If pets leak into player lists, verify actual type
  values via DebugWindow dump — expansion patches can shift ObjectTypeID enums.
- me.power returns the spec's primary resource (Maelstrom, Runic Power, etc.) directly.
  Use powerByType() only when you need a secondary resource.
- Aura .remaining is in milliseconds. Use getAuraByMe() for debuffs you applied.
- combat.targets (from defaultCombatTargeting) is the enemy list; .length for count,
  combat.bestTarget for highest-priority target.

# Debugging
- console.info() inside a Decorator condition for per-tick logging.
- Clean up debug logs immediately after confirming the fix.
- If a spell "never fires," trace the Selector top-to-bottom for priority ordering bugs.
- For one-shot debugging, use Debug/DebugWindow.js dump buttons.
